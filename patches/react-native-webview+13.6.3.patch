diff --git a/node_modules/react-native-webview/android/src/main/java/com/reactnativecommunity/webview/RNCWebChromeClient.java b/node_modules/react-native-webview/android/src/main/java/com/reactnativecommunity/webview/RNCWebChromeClient.java
index 07f73fd..01976ae 100644
--- a/node_modules/react-native-webview/android/src/main/java/com/reactnativecommunity/webview/RNCWebChromeClient.java
+++ b/node_modules/react-native-webview/android/src/main/java/com/reactnativecommunity/webview/RNCWebChromeClient.java
@@ -3,10 +3,14 @@ package com.reactnativecommunity.webview;
 import android.Manifest;
 import android.annotation.TargetApi;
 import android.app.Activity;
+import android.app.AlertDialog;
+import android.content.DialogInterface;
 import android.content.pm.PackageManager;
 import android.net.Uri;
 import android.os.Build;
+import android.os.Handler;
 import android.os.Message;
+import android.text.TextUtils;
 import android.view.Gravity;
 import android.view.View;
 import android.view.ViewGroup;
@@ -17,6 +21,7 @@ import android.webkit.ValueCallback;
 import android.webkit.WebChromeClient;
 import android.webkit.WebView;
 import android.webkit.WebViewClient;
+import android.widget.Button;
 import android.widget.FrameLayout;
 
 import androidx.annotation.RequiresApi;
@@ -37,336 +42,373 @@ import java.util.Collections;
 import java.util.List;
 
 public class RNCWebChromeClient extends WebChromeClient implements LifecycleEventListener {
-    protected static final FrameLayout.LayoutParams FULLSCREEN_LAYOUT_PARAMS = new FrameLayout.LayoutParams(
-            ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.MATCH_PARENT, Gravity.CENTER);
+  protected static final FrameLayout.LayoutParams FULLSCREEN_LAYOUT_PARAMS = new FrameLayout.LayoutParams(
+    ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.MATCH_PARENT, Gravity.CENTER);
 
-    protected static final int FULLSCREEN_SYSTEM_UI_VISIBILITY = View.SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION |
-            View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN |
-            View.SYSTEM_UI_FLAG_LAYOUT_STABLE |
-            View.SYSTEM_UI_FLAG_HIDE_NAVIGATION |
-            View.SYSTEM_UI_FLAG_FULLSCREEN |
-            View.SYSTEM_UI_FLAG_IMMERSIVE |
-            View.SYSTEM_UI_FLAG_IMMERSIVE_STICKY;
+  protected static final int FULLSCREEN_SYSTEM_UI_VISIBILITY = View.SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION |
+    View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN |
+    View.SYSTEM_UI_FLAG_LAYOUT_STABLE |
+    View.SYSTEM_UI_FLAG_HIDE_NAVIGATION |
+    View.SYSTEM_UI_FLAG_FULLSCREEN |
+    View.SYSTEM_UI_FLAG_IMMERSIVE |
+    View.SYSTEM_UI_FLAG_IMMERSIVE_STICKY;
 
-    protected static final int COMMON_PERMISSION_REQUEST = 3;
+  protected static final int COMMON_PERMISSION_REQUEST = 3;
 
-    protected RNCWebView mWebView;
+  protected RNCWebView mWebView;
 
-    protected View mVideoView;
-    protected WebChromeClient.CustomViewCallback mCustomViewCallback;
+  protected View mVideoView;
+  protected WebChromeClient.CustomViewCallback mCustomViewCallback;
 
-    /*
-     * - Permissions -
-     * As native permissions are asynchronously handled by the PermissionListener, many fields have
-     * to be stored to send permissions results to the webview
-     */
+  /*
+   * - Permissions -
+   * As native permissions are asynchronously handled by the PermissionListener, many fields have
+   * to be stored to send permissions results to the webview
+   */
 
-    // Webview camera & audio permission callback
-    protected PermissionRequest permissionRequest;
-    // Webview camera & audio permission already granted
-    protected List<String> grantedPermissions;
+  // Webview camera & audio permission callback
+  protected PermissionRequest permissionRequest;
+  // Webview camera & audio permission already granted
+  protected List<String> grantedPermissions;
 
-    // Webview geolocation permission callback
-    protected GeolocationPermissions.Callback geolocationPermissionCallback;
-    // Webview geolocation permission origin callback
-    protected String geolocationPermissionOrigin;
+  // Webview geolocation permission callback
+  protected GeolocationPermissions.Callback geolocationPermissionCallback;
+  // Webview geolocation permission origin callback
+  protected String geolocationPermissionOrigin;
 
-    // true if native permissions dialog is shown, false otherwise
-    protected boolean permissionsRequestShown = false;
-    // Pending Android permissions for the next request
-    protected List<String> pendingPermissions = new ArrayList<>();
+  // true if native permissions dialog is shown, false otherwise
+  protected boolean permissionsRequestShown = false;
+  // Pending Android permissions for the next request
+  protected List<String> pendingPermissions = new ArrayList<>();
 
-    protected RNCWebView.ProgressChangedFilter progressChangedFilter = null;
-    protected boolean mAllowsProtectedMedia = false;
+  protected RNCWebView.ProgressChangedFilter progressChangedFilter = null;
+  protected boolean mAllowsProtectedMedia = false;
 
-    protected boolean mHasOnOpenWindowEvent = false;
+  protected boolean mHasOnOpenWindowEvent = false;
 
-    public RNCWebChromeClient(RNCWebView webView) {
-        this.mWebView = webView;
-    }
+  public RNCWebChromeClient(RNCWebView webView) {
+    this.mWebView = webView;
+  }
 
-    @Override
-    public boolean onCreateWindow(WebView view, boolean isDialog, boolean isUserGesture, Message resultMsg) {
+  @Override
+  public boolean onCreateWindow(WebView view, boolean isDialog, boolean isUserGesture, Message resultMsg) {
 
-        final WebView newWebView = new WebView(view.getContext());
+    final WebView newWebView = new WebView(view.getContext());
 
-        if(mHasOnOpenWindowEvent) {
-            newWebView.setWebViewClient(new WebViewClient(){
-            @Override
-            public boolean shouldOverrideUrlLoading (WebView subview, String url) {
-                WritableMap event = Arguments.createMap();
-                event.putString("targetUrl", url);
+    if (mHasOnOpenWindowEvent) {
+      newWebView.setWebViewClient(new WebViewClient() {
+        @Override
+        public boolean shouldOverrideUrlLoading(WebView subview, String url) {
+          WritableMap event = Arguments.createMap();
+          event.putString("targetUrl", url);
 
-                ((RNCWebView) view).dispatchEvent(
-                    view,
-                    new TopOpenWindowEvent(RNCWebViewWrapper.getReactTagFromWebView(view), event)
-                );
+          ((RNCWebView) view).dispatchEvent(
+            view,
+            new TopOpenWindowEvent(RNCWebViewWrapper.getReactTagFromWebView(view), event)
+          );
 
-                return true;
-            }
-            });
+          return true;
         }
+      });
+    }
 
-        final WebView.WebViewTransport transport = (WebView.WebViewTransport) resultMsg.obj;
-        transport.setWebView(newWebView);
-        resultMsg.sendToTarget();
+    final WebView.WebViewTransport transport = (WebView.WebViewTransport) resultMsg.obj;
+    transport.setWebView(newWebView);
+    resultMsg.sendToTarget();
 
-        return true;
-    }
+    return true;
+  }
 
-    @Override
-    public boolean onConsoleMessage(ConsoleMessage message) {
-        if (ReactBuildConfig.DEBUG) {
-            return super.onConsoleMessage(message);
-        }
-        // Ignore console logs in non debug builds.
-        return true;
+  @Override
+  public boolean onConsoleMessage(ConsoleMessage message) {
+    if (ReactBuildConfig.DEBUG) {
+      return super.onConsoleMessage(message);
     }
-
-    @Override
-    public void onProgressChanged(WebView webView, int newProgress) {
-        super.onProgressChanged(webView, newProgress);
-        final String url = webView.getUrl();
-        if (progressChangedFilter.isWaitingForCommandLoadUrl()) {
-            return;
-        }
-        int reactTag = RNCWebViewWrapper.getReactTagFromWebView(webView);
-        WritableMap event = Arguments.createMap();
-        event.putDouble("target", reactTag);
-        event.putString("title", webView.getTitle());
-        event.putString("url", url);
-        event.putBoolean("canGoBack", webView.canGoBack());
-        event.putBoolean("canGoForward", webView.canGoForward());
-        event.putDouble("progress", (float) newProgress / 100);
-
-        UIManagerHelper.getEventDispatcherForReactTag(this.mWebView.getThemedReactContext(), reactTag).dispatchEvent(new TopLoadingProgressEvent(reactTag, event));
+    // Ignore console logs in non debug builds.
+    return true;
+  }
+
+  @Override
+  public void onProgressChanged(WebView webView, int newProgress) {
+    super.onProgressChanged(webView, newProgress);
+    final String url = webView.getUrl();
+    if (progressChangedFilter.isWaitingForCommandLoadUrl()) {
+      return;
     }
-
-    @Override
-    public void onPermissionRequest(final PermissionRequest request) {
-
-        grantedPermissions = new ArrayList<>();
-
-        ArrayList<String> requestedAndroidPermissions = new ArrayList<>();
-        for (String requestedResource : request.getResources()) {
-            String androidPermission = null;
-
-            if (requestedResource.equals(PermissionRequest.RESOURCE_AUDIO_CAPTURE)) {
-                androidPermission = Manifest.permission.RECORD_AUDIO;
-            } else if (requestedResource.equals(PermissionRequest.RESOURCE_VIDEO_CAPTURE)) {
-                androidPermission = Manifest.permission.CAMERA;
-            } else if(requestedResource.equals(PermissionRequest.RESOURCE_PROTECTED_MEDIA_ID)) {
-                if (mAllowsProtectedMedia) {
-                  grantedPermissions.add(requestedResource);
-                } else {
-                  /**
-                   * Legacy handling (Kept in case it was working under some conditions (given Android version or something))
-                   *
-                   * Try to ask user to grant permission using Activity.requestPermissions
-                   *
-                   * Find more details here: https://github.com/react-native-webview/react-native-webview/pull/2732
-                   */
-                  androidPermission = PermissionRequest.RESOURCE_PROTECTED_MEDIA_ID;
-                }            }
-            // TODO: RESOURCE_MIDI_SYSEX, RESOURCE_PROTECTED_MEDIA_ID.
-            if (androidPermission != null) {
-                if (ContextCompat.checkSelfPermission(this.mWebView.getThemedReactContext(), androidPermission) == PackageManager.PERMISSION_GRANTED) {
-                    grantedPermissions.add(requestedResource);
-                } else {
-                    requestedAndroidPermissions.add(androidPermission);
-                }
-            }
+    int reactTag = RNCWebViewWrapper.getReactTagFromWebView(webView);
+    WritableMap event = Arguments.createMap();
+    event.putDouble("target", reactTag);
+    event.putString("title", webView.getTitle());
+    event.putString("url", url);
+    event.putBoolean("canGoBack", webView.canGoBack());
+    event.putBoolean("canGoForward", webView.canGoForward());
+    event.putDouble("progress", (float) newProgress / 100);
+
+    UIManagerHelper.getEventDispatcherForReactTag(this.mWebView.getThemedReactContext(), reactTag).dispatchEvent(new TopLoadingProgressEvent(reactTag, event));
+  }
+
+  @Override
+  public void onPermissionRequest(final PermissionRequest request) {
+
+    grantedPermissions = new ArrayList<>();
+    ArrayList<String> requestPermissionIdentifiers = new ArrayList<>();
+
+    ArrayList<String> requestedAndroidPermissions = new ArrayList<>();
+    for (String requestedResource : request.getResources()) {
+      String androidPermission = null;
+
+      if (requestedResource.equals(PermissionRequest.RESOURCE_AUDIO_CAPTURE)) {
+        androidPermission = Manifest.permission.RECORD_AUDIO;
+        requestPermissionIdentifiers.add("microphone");
+      } else if (requestedResource.equals(PermissionRequest.RESOURCE_VIDEO_CAPTURE)) {
+        androidPermission = Manifest.permission.CAMERA;
+        requestPermissionIdentifiers.add("camera");
+      } else if (requestedResource.equals(PermissionRequest.RESOURCE_PROTECTED_MEDIA_ID)) {
+        if (mAllowsProtectedMedia) {
+          grantedPermissions.add(requestedResource);
+        } else {
+          /**
+           * Legacy handling (Kept in case it was working under some conditions (given Android version or something))
+           *
+           * Try to ask user to grant permission using Activity.requestPermissions
+           *
+           * Find more details here: https://github.com/react-native-webview/react-native-webview/pull/2732
+           */
+          androidPermission = PermissionRequest.RESOURCE_PROTECTED_MEDIA_ID;
         }
-
-        // If all the permissions are already granted, send the response to the WebView synchronously
-        if (requestedAndroidPermissions.isEmpty()) {
-            request.grant(grantedPermissions.toArray(new String[0]));
-            grantedPermissions = null;
-            return;
+      }
+      // TODO: RESOURCE_MIDI_SYSEX, RESOURCE_PROTECTED_MEDIA_ID.
+      if (androidPermission != null) {
+        if (ContextCompat.checkSelfPermission(this.mWebView.getThemedReactContext(), androidPermission) == PackageManager.PERMISSION_GRANTED) {
+          grantedPermissions.add(requestedResource);
+        } else {
+          requestedAndroidPermissions.add(androidPermission);
         }
+      }
+    }
 
-        // Otherwise, ask to Android System for native permissions asynchronously
-
-        this.permissionRequest = request;
-
+    // Otherwise, ask to Android System for native permissions asynchronously
+    if (!requestedAndroidPermissions.isEmpty()) {
+      // Show the dialog and request the permissions
+      AlertDialog.Builder builder = new AlertDialog.Builder(this.mWebView.getThemedReactContext());
+      String permissionsIdentifiers = TextUtils.join(" and ", requestPermissionIdentifiers);
+      builder.setMessage("The app needs access to your " + permissionsIdentifiers + ". Allow?");
+      builder.setCancelable(false);
+      builder.setPositiveButton("Allow", (dialog, which) -> {
+        permissionRequest = request;
         requestPermissions(requestedAndroidPermissions);
+      });
+      builder.setNegativeButton("Don't allow", (dialog, which) -> {
+        request.deny();
+      });
+
+      AlertDialog alertDialog = builder.create();
+      alertDialog.show();
+      // Delay making `allow` clickable for 500ms
+      Button posButton = alertDialog.getButton(AlertDialog.BUTTON_POSITIVE);
+      posButton.setEnabled(false);
+      this.runDelayed(() -> posButton.setEnabled(true), 500);
+    } else if (!grantedPermissions.isEmpty()) {
+      // You need to show to the user that the website is requesting permissions
+      // If that happens and the permissions are already granted you need to ask again
+      AlertDialog.Builder builder = new AlertDialog.Builder(this.mWebView.getThemedReactContext());
+      String permissionsIdentifiers = TextUtils.join(" and ", requestPermissionIdentifiers);
+      builder.setMessage("The app needs access to your " + permissionsIdentifiers + ". Allow?");
+      builder.setCancelable(false);
+      builder.setPositiveButton("Allow", (dialog, which) -> request.grant(grantedPermissions.toArray(new String[0])));
+      builder.setNegativeButton("Don't allow", (dialog, which) -> {
+        request.deny();
+      });
+      AlertDialog alertDialog = builder.create();
+      alertDialog.show();
+      // Delay making `allow` clickable for 500ms
+      Button posButton = alertDialog.getButton(AlertDialog.BUTTON_POSITIVE);
+      posButton.setEnabled(false);
+      this.runDelayed(() -> posButton.setEnabled(true), 500);
     }
+  }
 
+  private void runDelayed(Runnable function, long delayMillis) {
+    Handler handler = new Handler();
+    handler.postDelayed(function, delayMillis);
+  }
 
-    @Override
-    public void onGeolocationPermissionsShowPrompt(String origin, GeolocationPermissions.Callback callback) {
+  @Override
+  public void onGeolocationPermissionsShowPrompt(String origin, GeolocationPermissions.Callback callback) {
 
-        if (ContextCompat.checkSelfPermission(this.mWebView.getThemedReactContext(), Manifest.permission.ACCESS_FINE_LOCATION)
-                != PackageManager.PERMISSION_GRANTED) {
+    if (ContextCompat.checkSelfPermission(this.mWebView.getThemedReactContext(), Manifest.permission.ACCESS_FINE_LOCATION)
+      != PackageManager.PERMISSION_GRANTED) {
 
-            /*
-             * Keep the trace of callback and origin for the async permission request
-             */
-            geolocationPermissionCallback = callback;
-            geolocationPermissionOrigin = origin;
+      /*
+       * Keep the trace of callback and origin for the async permission request
+       */
+      geolocationPermissionCallback = callback;
+      geolocationPermissionOrigin = origin;
 
-            requestPermissions(Collections.singletonList(Manifest.permission.ACCESS_FINE_LOCATION));
+      requestPermissions(Collections.singletonList(Manifest.permission.ACCESS_FINE_LOCATION));
 
-        } else {
-            callback.invoke(origin, true, false);
-        }
+    } else {
+      callback.invoke(origin, true, false);
     }
-
-    private PermissionAwareActivity getPermissionAwareActivity() {
-        Activity activity = this.mWebView.getThemedReactContext().getCurrentActivity();
-        if (activity == null) {
-            throw new IllegalStateException("Tried to use permissions API while not attached to an Activity.");
-        } else if (!(activity instanceof PermissionAwareActivity)) {
-            throw new IllegalStateException("Tried to use permissions API but the host Activity doesn't implement PermissionAwareActivity.");
-        }
-        return (PermissionAwareActivity) activity;
+  }
+
+  private PermissionAwareActivity getPermissionAwareActivity() {
+    Activity activity = this.mWebView.getThemedReactContext().getCurrentActivity();
+    if (activity == null) {
+      throw new IllegalStateException("Tried to use permissions API while not attached to an Activity.");
+    } else if (!(activity instanceof PermissionAwareActivity)) {
+      throw new IllegalStateException("Tried to use permissions API but the host Activity doesn't implement PermissionAwareActivity.");
     }
+    return (PermissionAwareActivity) activity;
+  }
 
-    private synchronized void requestPermissions(List<String> permissions) {
+  private synchronized void requestPermissions(List<String> permissions) {
 
-        /*
-         * If permissions request dialog is displayed on the screen and another request is sent to the
-         * activity, the last permission asked is skipped. As a work-around, we use pendingPermissions
-         * to store next required permissions.
-         */
-
-        if (permissionsRequestShown) {
-            pendingPermissions.addAll(permissions);
-            return;
-        }
-
-        PermissionAwareActivity activity = getPermissionAwareActivity();
-        permissionsRequestShown = true;
-
-        activity.requestPermissions(
-                permissions.toArray(new String[0]),
-                COMMON_PERMISSION_REQUEST,
-                webviewPermissionsListener
-        );
+    /*
+     * If permissions request dialog is displayed on the screen and another request is sent to the
+     * activity, the last permission asked is skipped. As a work-around, we use pendingPermissions
+     * to store next required permissions.
+     */
 
-        // Pending permissions have been sent, the list can be cleared
-        pendingPermissions.clear();
+    if (permissionsRequestShown) {
+      pendingPermissions.addAll(permissions);
+      return;
     }
 
+    PermissionAwareActivity activity = getPermissionAwareActivity();
+    permissionsRequestShown = true;
 
-    private PermissionListener webviewPermissionsListener = (requestCode, permissions, grantResults) -> {
-
-        permissionsRequestShown = false;
+    activity.requestPermissions(
+      permissions.toArray(new String[0]),
+      COMMON_PERMISSION_REQUEST,
+      webviewPermissionsListener
+    );
 
-        /*
-         * As a "pending requests" approach is used, requestCode cannot help to define if the request
-         * came from geolocation or camera/audio. This is why shouldAnswerToPermissionRequest is used
-         */
-        boolean shouldAnswerToPermissionRequest = false;
+    // Pending permissions have been sent, the list can be cleared
+    pendingPermissions.clear();
+  }
 
-        for (int i = 0; i < permissions.length; i++) {
 
-            String permission = permissions[i];
-            boolean granted = grantResults[i] == PackageManager.PERMISSION_GRANTED;
+  private PermissionListener webviewPermissionsListener = (requestCode, permissions, grantResults) -> {
 
-            if (permission.equals(Manifest.permission.ACCESS_FINE_LOCATION)
-                    && geolocationPermissionCallback != null
-                    && geolocationPermissionOrigin != null) {
+    permissionsRequestShown = false;
 
-                if (granted) {
-                    geolocationPermissionCallback.invoke(geolocationPermissionOrigin, true, false);
-                } else {
-                    geolocationPermissionCallback.invoke(geolocationPermissionOrigin, false, false);
-                }
+    /*
+     * As a "pending requests" approach is used, requestCode cannot help to define if the request
+     * came from geolocation or camera/audio. This is why shouldAnswerToPermissionRequest is used
+     */
+    boolean shouldAnswerToPermissionRequest = false;
 
-                geolocationPermissionCallback = null;
-                geolocationPermissionOrigin = null;
-            }
+    for (int i = 0; i < permissions.length; i++) {
 
-            if (permission.equals(Manifest.permission.RECORD_AUDIO)) {
-                if (granted && grantedPermissions != null) {
-                    grantedPermissions.add(PermissionRequest.RESOURCE_AUDIO_CAPTURE);
-                }
-                shouldAnswerToPermissionRequest = true;
-            }
+      String permission = permissions[i];
+      boolean granted = grantResults[i] == PackageManager.PERMISSION_GRANTED;
 
-            if (permission.equals(Manifest.permission.CAMERA)) {
-                if (granted && grantedPermissions != null) {
-                    grantedPermissions.add(PermissionRequest.RESOURCE_VIDEO_CAPTURE);
-                }
-                shouldAnswerToPermissionRequest = true;
-            }
+      if (permission.equals(Manifest.permission.ACCESS_FINE_LOCATION)
+        && geolocationPermissionCallback != null
+        && geolocationPermissionOrigin != null) {
 
-            if (permission.equals(PermissionRequest.RESOURCE_PROTECTED_MEDIA_ID)) {
-                if (granted && grantedPermissions != null) {
-                    grantedPermissions.add(PermissionRequest.RESOURCE_PROTECTED_MEDIA_ID);
-                }
-                shouldAnswerToPermissionRequest = true;
-            }
+        if (granted) {
+          geolocationPermissionCallback.invoke(geolocationPermissionOrigin, true, false);
+        } else {
+          geolocationPermissionCallback.invoke(geolocationPermissionOrigin, false, false);
         }
 
-        if (shouldAnswerToPermissionRequest
-                && permissionRequest != null
-                && grantedPermissions != null) {
-            permissionRequest.grant(grantedPermissions.toArray(new String[0]));
-            permissionRequest = null;
-            grantedPermissions = null;
-        }
+        geolocationPermissionCallback = null;
+        geolocationPermissionOrigin = null;
+      }
 
-        if (!pendingPermissions.isEmpty()) {
-            requestPermissions(pendingPermissions);
-            return false;
+      if (permission.equals(Manifest.permission.RECORD_AUDIO)) {
+        if (granted && grantedPermissions != null) {
+          grantedPermissions.add(PermissionRequest.RESOURCE_AUDIO_CAPTURE);
         }
+        shouldAnswerToPermissionRequest = true;
+      }
 
-        return true;
-    };
-
-    protected void openFileChooser(ValueCallback<Uri> filePathCallback, String acceptType) {
-      this.mWebView.getThemedReactContext().getNativeModule(RNCWebViewModule.class).startPhotoPickerIntent(filePathCallback, acceptType);
-    }
+      if (permission.equals(Manifest.permission.CAMERA)) {
+        if (granted && grantedPermissions != null) {
+          grantedPermissions.add(PermissionRequest.RESOURCE_VIDEO_CAPTURE);
+        }
+        shouldAnswerToPermissionRequest = true;
+      }
 
-    protected void openFileChooser(ValueCallback<Uri> filePathCallback) {
-      this.mWebView.getThemedReactContext().getNativeModule(RNCWebViewModule.class).startPhotoPickerIntent(filePathCallback, "");
+      if (permission.equals(PermissionRequest.RESOURCE_PROTECTED_MEDIA_ID)) {
+        if (granted && grantedPermissions != null) {
+          grantedPermissions.add(PermissionRequest.RESOURCE_PROTECTED_MEDIA_ID);
+        }
+        shouldAnswerToPermissionRequest = true;
+      }
     }
 
-    protected void openFileChooser(ValueCallback<Uri> filePathCallback, String acceptType, String capture) {
-      this.mWebView.getThemedReactContext().getNativeModule(RNCWebViewModule.class).startPhotoPickerIntent(filePathCallback, acceptType);
+    if (shouldAnswerToPermissionRequest
+      && permissionRequest != null
+      && grantedPermissions != null) {
+      permissionRequest.grant(grantedPermissions.toArray(new String[0]));
+      permissionRequest = null;
+      grantedPermissions = null;
     }
 
-    @Override
-    public boolean onShowFileChooser(WebView webView, ValueCallback<Uri[]> filePathCallback, FileChooserParams fileChooserParams) {
-        String[] acceptTypes = fileChooserParams.getAcceptTypes();
-        boolean allowMultiple = fileChooserParams.getMode() == WebChromeClient.FileChooserParams.MODE_OPEN_MULTIPLE;
-
-        return this.mWebView.getThemedReactContext().getNativeModule(RNCWebViewModule.class).startPhotoPickerIntent(filePathCallback, acceptTypes, allowMultiple, fileChooserParams.isCaptureEnabled());
+    if (!pendingPermissions.isEmpty()) {
+      requestPermissions(pendingPermissions);
+      return false;
     }
 
-    @Override
-    public void onHostResume() {
-        if (mVideoView != null && mVideoView.getSystemUiVisibility() != FULLSCREEN_SYSTEM_UI_VISIBILITY) {
-            mVideoView.setSystemUiVisibility(FULLSCREEN_SYSTEM_UI_VISIBILITY);
-        }
-    }
+    return true;
+  };
 
-    @Override
-    public void onHostPause() { }
+  protected void openFileChooser(ValueCallback<Uri> filePathCallback, String acceptType) {
+    this.mWebView.getThemedReactContext().getNativeModule(RNCWebViewModule.class).startPhotoPickerIntent(filePathCallback, acceptType);
+  }
 
-    @Override
-    public void onHostDestroy() { }
+  protected void openFileChooser(ValueCallback<Uri> filePathCallback) {
+    this.mWebView.getThemedReactContext().getNativeModule(RNCWebViewModule.class).startPhotoPickerIntent(filePathCallback, "");
+  }
 
-    protected ViewGroup getRootView() {
-        return this.mWebView.getThemedReactContext().getCurrentActivity().findViewById(android.R.id.content);
-    }
+  protected void openFileChooser(ValueCallback<Uri> filePathCallback, String acceptType, String capture) {
+    this.mWebView.getThemedReactContext().getNativeModule(RNCWebViewModule.class).startPhotoPickerIntent(filePathCallback, acceptType);
+  }
 
-    public void setProgressChangedFilter(RNCWebView.ProgressChangedFilter filter) {
-        progressChangedFilter = filter;
-    }
+  @Override
+  public boolean onShowFileChooser(WebView webView, ValueCallback<Uri[]> filePathCallback, FileChooserParams fileChooserParams) {
+    String[] acceptTypes = fileChooserParams.getAcceptTypes();
+    boolean allowMultiple = fileChooserParams.getMode() == WebChromeClient.FileChooserParams.MODE_OPEN_MULTIPLE;
 
-    /**
-     * Set whether or not protected media should be allowed
-     * /!\ Setting this to false won't revoke permission already granted to the current webpage.
-     * In order to do so, you'd need to reload the page /!\
-     */
-    public void setAllowsProtectedMedia(boolean enabled) {
-      mAllowsProtectedMedia = enabled;
-    }
+    return this.mWebView.getThemedReactContext().getNativeModule(RNCWebViewModule.class).startPhotoPickerIntent(filePathCallback, acceptTypes, allowMultiple, fileChooserParams.isCaptureEnabled());
+  }
 
-    public void setHasOnOpenWindowEvent(boolean hasEvent) {
-      mHasOnOpenWindowEvent = hasEvent;
+  @Override
+  public void onHostResume() {
+    if (mVideoView != null && mVideoView.getSystemUiVisibility() != FULLSCREEN_SYSTEM_UI_VISIBILITY) {
+      mVideoView.setSystemUiVisibility(FULLSCREEN_SYSTEM_UI_VISIBILITY);
     }
+  }
+
+  @Override
+  public void onHostPause() {
+  }
+
+  @Override
+  public void onHostDestroy() {
+  }
+
+  protected ViewGroup getRootView() {
+    return this.mWebView.getThemedReactContext().getCurrentActivity().findViewById(android.R.id.content);
+  }
+
+  public void setProgressChangedFilter(RNCWebView.ProgressChangedFilter filter) {
+    progressChangedFilter = filter;
+  }
+
+  /**
+   * Set whether or not protected media should be allowed
+   * /!\ Setting this to false won't revoke permission already granted to the current webpage.
+   * In order to do so, you'd need to reload the page /!\
+   */
+  public void setAllowsProtectedMedia(boolean enabled) {
+    mAllowsProtectedMedia = enabled;
+  }
+
+  public void setHasOnOpenWindowEvent(boolean hasEvent) {
+    mHasOnOpenWindowEvent = hasEvent;
+  }
 }
diff --git a/node_modules/react-native-webview/apple/RNCWebViewImpl.m b/node_modules/react-native-webview/apple/RNCWebViewImpl.m
index a59c258..a097363 100644
--- a/node_modules/react-native-webview/apple/RNCWebViewImpl.m
+++ b/node_modules/react-native-webview/apple/RNCWebViewImpl.m
@@ -143,6 +143,7 @@ RCTAutoInsetsProtocol>
   UIStatusBarStyle _savedStatusBarStyle;
 #endif // !TARGET_OS_OSX
   BOOL _savedStatusBarHidden;
+  BOOL _disablePromptDuringLoading; //Disables the display of prompts during site navigation/loading
 
 #if defined(__IPHONE_OS_VERSION_MAX_ALLOWED) && __IPHONE_OS_VERSION_MAX_ALLOWED >= 110000 /* __IPHONE_11_0 */
   UIScrollViewContentInsetAdjustmentBehavior _savedContentInsetAdjustmentBehavior;
@@ -177,6 +178,7 @@ RCTAutoInsetsProtocol>
     _injectedJavaScriptForMainFrameOnly = YES;
     _injectedJavaScriptBeforeContentLoaded = nil;
     _injectedJavaScriptBeforeContentLoadedForMainFrameOnly = YES;
+    _disablePromptDuringLoading = YES;
 
 #if defined(__IPHONE_OS_VERSION_MAX_ALLOWED) && __IPHONE_OS_VERSION_MAX_ALLOWED >= 110000 /* __IPHONE_11_0 */
     _savedContentInsetAdjustmentBehavior = UIScrollViewContentInsetAdjustmentNever;
@@ -649,6 +651,7 @@ RCTAutoInsetsProtocol>
 - (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary<NSKeyValueChangeKey,id> *)change context:(void *)context{
   if ([keyPath isEqual:@"estimatedProgress"] && object == self.webView) {
     if(_onLoadingProgress){
+      _disablePromptDuringLoading = YES;
       NSMutableDictionary<NSString *, id> *event = [self baseEvent];
       [event addEntriesFromDictionary:@{@"progress":[NSNumber numberWithDouble:self.webView.estimatedProgress]}];
       _onLoadingProgress(event);
@@ -726,6 +729,7 @@ RCTAutoInsetsProtocol>
       NSMutableDictionary<NSString *, id> *event = [self baseEvent];
       [event addEntriesFromDictionary: @{@"navigationType": message.body}];
       _onLoadingFinish(event);
+      _disablePromptDuringLoading = NO;
     }
   } else if ([message.name isEqualToString:MessageHandlerName]) {
     if (_onMessage) {
@@ -1107,11 +1111,13 @@ RCTAutoInsetsProtocol>
 - (void)webView:(WKWebView *)webView runJavaScriptAlertPanelWithMessage:(NSString *)message initiatedByFrame:(WKFrameInfo *)frame completionHandler:(void (^)(void))completionHandler
 {
 #if !TARGET_OS_OSX
-  UIAlertController *alert = [UIAlertController alertControllerWithTitle:@"" message:message preferredStyle:UIAlertControllerStyleAlert];
-  [alert addAction:[UIAlertAction actionWithTitle:@"Ok" style:UIAlertActionStyleDefault handler:^(UIAlertAction *action) {
-    completionHandler();
-  }]];
-  [[self topViewController] presentViewController:alert animated:YES completion:NULL];
+  dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(0.7 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{
+    UIAlertController *alert = [UIAlertController alertControllerWithTitle:@"" message:message preferredStyle:UIAlertControllerStyleAlert];
+    [alert addAction:[UIAlertAction actionWithTitle:@"Ok" style:UIAlertActionStyleDefault handler:^(UIAlertAction *action) {
+      completionHandler();
+    }]];
+    [[self topViewController] presentViewController:alert animated:YES completion:NULL];
+  });
 #else
   NSAlert *alert = [[NSAlert alloc] init];
   [alert setMessageText:message];
@@ -1150,44 +1156,46 @@ RCTAutoInsetsProtocol>
  * prompt
  */
 - (void)webView:(WKWebView *)webView runJavaScriptTextInputPanelWithPrompt:(NSString *)prompt defaultText:(NSString *)defaultText initiatedByFrame:(WKFrameInfo *)frame completionHandler:(void (^)(NSString *))completionHandler{
-#if !TARGET_OS_OSX
-  UIAlertController *alert = [UIAlertController alertControllerWithTitle:@"" message:prompt preferredStyle:UIAlertControllerStyleAlert];
-  [alert addTextFieldWithConfigurationHandler:^(UITextField *textField) {
-    textField.text = defaultText;
-  }];
-  UIAlertAction *okAction = [UIAlertAction actionWithTitle:@"Ok" style:UIAlertActionStyleDefault handler:^(UIAlertAction *action) {
-    completionHandler([[alert.textFields lastObject] text]);
-  }];
-  [alert addAction:okAction];
-  UIAlertAction *cancelAction = [UIAlertAction actionWithTitle:@"Cancel" style:UIAlertActionStyleCancel handler:^(UIAlertAction *action) {
+  if(!_disablePromptDuringLoading) {
+    #if !TARGET_OS_OSX
+      UIAlertController *alert = [UIAlertController alertControllerWithTitle:@"" message:prompt preferredStyle:UIAlertControllerStyleAlert];
+      [alert addTextFieldWithConfigurationHandler:^(UITextField *textField) {
+        textField.text = defaultText;
+      }];
+      UIAlertAction *okAction = [UIAlertAction actionWithTitle:@"Ok" style:UIAlertActionStyleDefault handler:^(UIAlertAction *action) {
+        completionHandler([[alert.textFields lastObject] text]);
+      }];
+      [alert addAction:okAction];
+      UIAlertAction *cancelAction = [UIAlertAction actionWithTitle:@"Cancel" style:UIAlertActionStyleCancel handler:^(UIAlertAction *action) {
+        completionHandler(nil);
+      }];
+      [alert addAction:cancelAction];
+      alert.preferredAction = okAction;
+      [[self topViewController] presentViewController:alert animated:YES completion:NULL];
+    #else
+      NSAlert *alert = [[NSAlert alloc] init];
+      [alert setMessageText:prompt];
+      const NSRect RCTSingleTextFieldFrame = NSMakeRect(0.0, 0.0, 275.0, 22.0);
+      NSTextField *textField = [[NSTextField alloc] initWithFrame:RCTSingleTextFieldFrame];
+      textField.cell.scrollable = YES;
+      if (@available(macOS 10.11, *)) {
+        textField.maximumNumberOfLines = 1;
+      }
+      textField.stringValue = defaultText;
+      [alert setAccessoryView:textField];
+      [alert addButtonWithTitle:NSLocalizedString(@"OK", @"OK button")];
+      [alert addButtonWithTitle:NSLocalizedString(@"Cancel", @"Cancel button")];
+      [alert beginSheetModalForWindow:[NSApp keyWindow] completionHandler:^(NSModalResponse response) {
+        if (response == NSAlertFirstButtonReturn) {
+          completionHandler([textField stringValue]);
+        } else {
+          completionHandler(nil);
+        }
+      }];
+    #endif // !TARGET_OS_OSX
+  } else {
     completionHandler(nil);
-  }];
-  [alert addAction:cancelAction];
-  alert.preferredAction = okAction;
-  [[self topViewController] presentViewController:alert animated:YES completion:NULL];
-#else
-  NSAlert *alert = [[NSAlert alloc] init];
-  [alert setMessageText:prompt];
-
-  const NSRect RCTSingleTextFieldFrame = NSMakeRect(0.0, 0.0, 275.0, 22.0);
-  NSTextField *textField = [[NSTextField alloc] initWithFrame:RCTSingleTextFieldFrame];
-  textField.cell.scrollable = YES;
-  if (@available(macOS 10.11, *)) {
-    textField.maximumNumberOfLines = 1;
   }
-  textField.stringValue = defaultText;
-  [alert setAccessoryView:textField];
-
-  [alert addButtonWithTitle:NSLocalizedString(@"OK", @"OK button")];
-  [alert addButtonWithTitle:NSLocalizedString(@"Cancel", @"Cancel button")];
-  [alert beginSheetModalForWindow:[NSApp keyWindow] completionHandler:^(NSModalResponse response) {
-    if (response == NSAlertFirstButtonReturn) {
-      completionHandler([textField stringValue]);
-    } else {
-      completionHandler(nil);
-    }
-  }];
-#endif // !TARGET_OS_OSX
 }
 
 #if defined(__IPHONE_OS_VERSION_MAX_ALLOWED) && __IPHONE_OS_VERSION_MAX_ALLOWED >= 150000 /* iOS 15 */
@@ -1480,6 +1488,7 @@ didFinishNavigation:(WKNavigation *)navigation
   }
 
   if (_onLoadingFinish) {
+    _disablePromptDuringLoading = NO;
     _onLoadingFinish([self baseEvent]);
   }
 }
